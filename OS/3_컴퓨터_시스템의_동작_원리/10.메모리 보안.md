# 💿 메모리 보안

디스크 뿐 아니라 메모리의 경우에도 보안이 필요하다. 이는 여러 프로그램이 메모리에 동시에 올라가 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다.

따라서 적어도 인터럽트 벡터나 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요하다. 이는 사용자 프로그램이 인터럽트 처리 루틴에 접근하거나 변경할 수 있을 경우 운영체제만이 수행할 수 있는 특권명령을 보안성이 침해되는 이상한 명령으로 변형할 수 있기 때문이다.

> 이러한 문제를 해결하기 위해 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 메모리를 보호할 수 있다.

이때 사용되는 2개의 레지스터는 **기준 레지스터(Base register)와 한계 레지스터(Limit register)** 이다.

> 기준 레지스터는 어떤 프로그램이 실행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관하고 있고, 한계 레지스터는 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관하고 있다.

어떤 프로그램이 메모리에 접근할 때마다 하드웨어적으로 현재 접근하려는 위치가 **기준 레지스터의 주소값**부터 **기준 레지스터 + 한계 레지스터**의 값 사이에 있는지 체크하게 된다.

> 해당 범위 내에 없으면 불법적인 메모리 접근이므로 예외상황이라는 일종의 소프트웨어 인터럽트가 발생한다.

예외상황은 운영체제에 소프트웨어 인터럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 운영체제는 예외상황을 발생시킨 프로그램을 강제적으로 종료시킨다.

단 여기에서 살펴본 기준 레지스터와 한계 레지스터를 통한 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법을 사용하는 경우에 한정된 설명이다.

메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안 수행할 수 있는 연산이므로 특권명령은 아니다. 다만 사용자 프로그램이 메모리에 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리를 보호하게 된다. 이것이 운영체제만이 수행할 수 있는 입출력 연산과 메모리 접근 연산의 차이점이라고 할 수 있다.

> 참고) 커널모드에서는 메모리에 무제한적으로 접근하는 것이 가능하다.

메모리 접근 연산이 특권명령은 아니지만, 올바르지 않은 접근 시도로부터 메모리를 보호하기 위해선 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산을 특권명령으로 규정해야 한다.
