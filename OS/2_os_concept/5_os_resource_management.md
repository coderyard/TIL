# 🛹 OS의 자원 관리 기능

> OS의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것이며, 여기서 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다.

---

## 하드웨어 자원

하드웨어 자원은 CPU와 메모리를 비롯해 주변장치 혹은 입출력 장치라고 불리는 장치로 이루어져 있다.

OS는 여러 프로세스(메모리에 올라간 프로그램)들이 CPU를 효율적으로 나눠 쓸 수 있도록 관리해야한다.

입출력 장치도 운영체제의 관리가 필요한데 CPU와 메모리는 휘발성 장치이기 때문에 전원이 나가도 기억해야 하는 부분을 입출력 장치 중 한 종류인 보조기억장치에 파일 형태로 저장한다.

이 때 이러한 파일들이 저장되는 방식 및 접근 권한 등에 대해서도 운영체제가 관리해야한다.

---

## CPU의 관리 방법

CPU가 하나밖에 없는 가장 기본적인 컴퓨터 구조에서도 프로세스는 여러 개가 동시에 수행될 수 있다.

그러므로 매 시점 어떠한 프로세스에 CPU를 할당해 처리할 것인지 결정하는 일이 필요하다.

> 이러한 일을 CPU 스케줄링이라고 한다. CPU 스케줄링의 목표는 CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 받지 않도록 하는 것이다.

대표적인 CPU 스케줄링 기법으로는 다음과 같다.

- FIFO (선입선출) : 먼저 도착한 프로세스를 처리하는 기법이다. CPU 자체의 효율적인 사용에는 문제가 없지만 전체 시스템 입장에서는 비효율적인 결과를 초래할 수 있다.

  > ex) 긴 실행 시간의 프로세스 도착 후 짧은 시간의 프로세스들이 도착했을 경우 짧은 프로세스들이 전부 기다려야 한다.

- RR (라운드 로빈) : CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간(퀀텀)으로 제한하는 기법이다.

  > 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 반환하고 대기열의 끝으로 이동한다.

  퀀텀(1회 할당 시간)은 수 밀리초 단위를 사용하며, 이 기법은 다수의 사용자가 동시에 접속할 때에도 각자 1초 이내의 응답시간을 보장받을 수 있게 된다.

- Priority (우선순위) : 대기 중인 프로세스들에게 우선순위를 부여하고, 우선순위가 높은 프로세스에 CPU를 먼저 할당하는 기법이다.

  > 시스템 내의 프로세스 중에는 상대적으로 더 중요한 프로세스들이 있을 수 있으므로 그런 프로세스의 우선순위를 높게 하여 CPU를 먼저 획득할 수 있도록 한다는 점이 우선순위 스케줄링의 핵심이다.

  또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 활용할 수 있다.

---

## 메모리 관리 기법

> 메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다.

프로그램이 프로세스로서 실행되기 위해서는 해당 부분이 메모리에 올라가 있어야 하는데 이때 한정된 메모리 공간에 여러 프로그램을 수용하려면 메모리에 대한 효율적인 관리 메커니즘이 필요하다.

> 메모리 관리를 위해 OS는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되는지를 파악하여 이를 유지하게 되는데, 이러한 정보는 주소(address)를 통해 관리된다.

프로그램에 메모리가 필요할 때 할당하고, 더이상 필요하지 않을 때 회수하며 다수의 사용자 프로그램이 동시에 메모리에 올라간 경우 서로 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 것도 운영체제의 몫이다.

> 즉, OS는 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 관리해야 한다.

### 물리적 메모리 관리 기법

물리적 메모리의 관리 기법에는 다음과 같은 것들이 있다.

- 고정분할 (fixed partition) : 물리적 메모리를 몇 개의 분할로 미리 나누어 관리하는 기법이다. 나뉜 각각의 분할에는 하나의 프로그램이 적재될 수 있다.

  이에 대한 단점으로는 융통성이 없다는 것이 있다. 메모리에 동시 적재되는 최대 프로그램의 개수가 분할의 개수로 제한되어 있기 때문이다. 또한, 분할의 크기보다 큰 프로그램은 적재가 불가능해진다.

  > 분할이 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우 해당 분할 내에 남는 영역이 발생하며 이를 **내부 조각 (internal fragmentation)** 이라고 한다.

  내부조각은 해당 분할에 올라온 프로그램에서도 사용되지 않고, 다른 프로그램에도 할당될 수 없으므로 비효율적으로 낭비되는 공간이다.

- 가변분할 (variable partition) : 매 시점 프로그램의 크기에 맞게 메모리를 분할하는 방식이다. 따라서 분할의 크기 때문에 큰 프로그램의 실행이 제한되는 문재는 발생하지 않으나 여전히 물리적 메모리의 크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.

  > 가변분할 방식에선 분할의 크기와 개수가 동적으로 변하므로 기술적 관리가 필요하다. 동적으로 할당하므로 내부조각은 발생하지 않지만 **외부조각 (external fragmentation)** 은 발생할 수 있다.

  외부조각이란 프로그램에 할당되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역이며 이 또한 낭비된 자원이다.

- 가상 메모리 (virtual memory) : 현대의 범용 컴퓨터에서 널리 쓰이는 기법으로 해당 기법은 물리적 메모리보다 큰 프로그램이 실행되는 것을 지원한다.

  이 때 실행될 수 있는 프로그램의 크기는 가상 메모리의 크기에 의해 결정된다.

  > 모든 프로그램은 물리적 메모리와는 독립적으로 0번지부터 시작되는 자신만의 가상 메모리 주소를 갖는다. 즉 사용할 수 있는 메모리의 크기가 충분히 크다고 가정하고 프로그램을 개발할 수 있다.

  현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식이다.

  이 때 사용되는 보조기억장치의 영역을 **스왑(swap)** 영역이라고 부른다. 프로그램을 구성하는 가상 메모리 주소공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다.

  > 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징 기법이라고 한다.

---

## 주변장치 관리

주변장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리가 이루어진다. 주변장치들은 CPU의 서비스가 필요한 경우 서비스를 요청하게 되는데 이 때 발생하는 신호를 **인터럽트(Interrupt)** 라고 한다.

CPU는 평소에 CPU 스케줄링에 따라 자기에게 주어진 작업을 수행하다가 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행한다.

> 이때 운영체제는 인터럽트를 처리한 후 원래 수행하던 작업으로 돌아오기 위해 작업의 상태(Process context)를 **PCB(Process Control Block)** 에 저장한다. 인터럽트를 처리하고 **컨텍스트 스위칭** 을 통해 이전에 처리하던 프로세스로 돌아오는 것이다.

인터럽트는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있기 때문에 운영체제는 인터럽트의 종류마다 서로 다른 인터럽트 처리 루틴을 가지고 있다.

> **인터럽트 처리 루틴(Interrupt Process Routine)** 란 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드이다.

인터럽트 처리 루틴의 경우 OS 내에 존재하는 코드로 CPU 스케줄링, 메모리 관리 루틴 등 다양한 기능을 위한 커널 코드의 일부분이라고 할 수 있다.

한편 주변장치들은 각 장치마다 그 장치에서 일어나는 업무를 관리하기 위한 일종의 작은 CPU인 **컨트롤러**를 가진다.

컨트롤러는 해당 장치에 대한 업무를 처리하고, 이를 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.

> ex) 사용자로부터 키보드에 입력이 들어오면 키보드 컨트롤러가 인터럽트를 발생시켜 CPU에 알린다.
